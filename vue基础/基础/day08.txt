vue-router
	1、是什么
		是vue官方的一个插件  和vuex类似
		专门用来实现一个SPA应用
		基于vue的项目基本都会用到此库
		vuex  vue-router  这两个插件应用比较广泛


	
	2、单页Web应用（single page web application，SPA）

		整个应用只有一个完整的页面（这个完整的页面，由多个组件组成）

		点击页面中的链接不会刷新页面, 本身也不会向服务器发普通请求

		当点击路由链接时，路径改变,  最终只会做页面的局部更新（组件切换）

		切换过来之后，数据都需要通过ajax请求获取, 并在前端异步展现




	3、路由器和路由
		路由器：管理路由使用的工具，路由器一个项目当中只能有一个


		路由：是一个key:value的映射关系


		前台路由   路径 和 组件
		{

			path:'/home',
			component:Home

		}
		当点击链接的时候，路径会发生变化，但是不会向服务器发普通请求，而是去显示对应的组件


		
		后台路由   路径 和 函数

		app.get('/users/info',function(req,res){

		})

		当点击链接（a标签）的时候，路径会发生变化，而且会向服务器发请求，
		然后匹配到后端的一个函数处理这个路由的请求，返回需要的数据





	4、简单理解前台路由：路由可以让我们实现组件的切换和跳转：
			点击链接，改变路径
			匹配路由，
			显示对应的组件




	5、路由组件和非路由组件
		
		组件： 代码和资源的集合就叫组件   

		非路由组件：  
			不需要路径的改变去切换
			定义：定义组件都是创建一个.vue文件,只是定义的位置不同，它是在components里面
			注册：在哪用在哪引入去注册，或者全局注册
			使用：在哪用在哪写组件标签，本质是内存中多了个组件对象
		
		路由组件：  	 
			需要路径的改变才能切换
		 	定义：定义组件都是创建一个.vue文件,只是定义的位置不同，它是在pages（views）里面
		 	注册：在路由器当中配置路由的时候注册
		 	使用：在固定的内置组件当中进行切换  <router-view />



	6、怎么做	

		1）、拆分页面定义组件
			路由组件和非路由组件
			

		2）、路由器注册路由组件（注册组件）：

			路由器的配置
				1、安装路由器   vue2安装的是3版本	
				2、引入并声明使用
				3、向外暴露一个路由器对象
				4、在main.js当中注入路由器对象
					在每个vue的组件当中都可以通过this.$router拿到路由器对象
  					this.$route拿到当前匹配到的路由对象

  			配置完路由器，你就可以配置路由，同时就注册了路由组件了
								
		3）、使用路由实现组件切换
			router-link    路由链接，就是点哪，可以让你的路径变为你指定的

			router-view    路由组件显示区域，就是组件需要在哪显示



	7、路由传参： 
		第一步：把参数写在路由链接路径当中,用户点击会修改路径   （字符串和对象）
		第二步：点击路由链接的时候，路径会去路由器当中的路由当中匹配，匹配同时会把参数解析添加到路由对象当中
		第三步：匹配成功，显示对应的路由组件同时把当前的路由对象让所有的组件（路由和非路由组件）都可以得到
		（props）

		参数：params参数,是属于路径的一部分       /message/10
			 query参数路径后使用?去拼接起来的,不属于路径    /xxx/  ? aa = bb && xx = yy 


		路由链接传递参数给路由的两种写法
			1、	字符串写法
					路由链接路由当中字符串拼接写法
					路由链接路由当中模板字符串写法
					 


			2、 对象写法
					命名路由









		使用props简化路由传参给组件操作（路由当中传参的三种操作）
			1）布尔值  
			路由当中需要配置 props:true,只能接收params参数，它会把路由当中接收的参数，置为组件的属性     
			2）对象
			很少用，只能给组件传递默认静态值
			3）函数
			用的比较多，比较灵活，可以把params和query的参数都映射为组件的属性
			props(route){ //route就是当前我这个路由对象
                    	  //把路由对象当中的参数，不管什么参数
                    	  //全部拿到作为组件的属性去使用
            	return {
                		msgId:route.params.msgId,
                		msgContent:route.query.msgContent
            	}
        	}



	8、编程式导航和声明式导航
		前面我们都是借助router-link 自动生成的跳转方式去跳转的，叫做声明式导航
		编程式导航：说白了就是让我们自己手写代码，去跳转


	9、声明式和编程式的区别？？？
		声明式简洁，不需要我们自己手写逻辑，直接就能跳转，我们不能加入自己的逻辑
		编程式导航，需要自己手写逻辑，才能跳转，我们可以加入自己的逻辑
		某些特定的场合下：编程式导航比声明式导航效率要高


	10、编程式导航的使用
		1)	this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面)
		2)	this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)
		3)	this.$router.back(): 请求(返回)上一个记录路由
		4)	this.$router.go(-1): 请求(返回)上一个记录路由
		5)	this.$router.go(1):  请求下一个记录路由
		$router.push()和$router.replace()的区别，返回有区别。
		$router.push()是往历史记录里面追加
		$router.replace()每一次都是覆盖添加

	

	10、路由组件和非路由组件的最大区别***************************
		除了在注册和使用的时候这两种组件有区别，其实他们的生命周期也是有很大区别的
		路由组件的生命周期是点击链接的时候，才开始的，路由组件才会创建，mounted才能执行
		路由组件在切换的时候，会被销毁，显示的时候重新创建

		
		同一个路由组件传参显示不同数据，mounted回调只会执行一次，因为是同一个组件


	
	11、缓存路由组件
		使用的是vue的一个内置组件，参考vue的官方文档
		使用这个东西可以保证我们在切换组件的时候，原来显示的组件不被销毁


		<keep-alive include="Home">   Home是对应的组件对象的名字，不是路由的名字
	        <router-view></router-view>
	     </keep-alive>



	12、路由模式	
		hash模式:
			 	路径中带#: http://localhost:8080/#/home/news
				发请求的路径: http://localhost:8080/  项目根路径
				响应: 返回的总是index页面  ==> path部分(/home/news)被解析为前台路由路径
				#是区分后台路径和前台路由路径的标志

		history模式:
				路径中不带#: http://localhost:8080/home/news
				发请求的路径: http://localhost:8080/home/news
				响应: 404错误

				希望: 如果没有对应的资源, 返回index页面, path部分(/home/news)被解析为前台路由路径

				解决: 添加配置
	    			devServer添加: historyApiFallback: true, // 任意的 404 响应都被替代为 index.html
	    			output添加: publicPath: '/', // 引入打包的文件时路径以/开头