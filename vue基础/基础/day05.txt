组件化开发当中的基本规范：
		1、数据在哪，修改数据的方法就在哪
		2、数据从父组件传递给子组件，无论传递的是基本值还是对象地址，都是让子组件去使用的，而不是让你去修改的
		3、props接收到的数据相当于是子组件data当中的数据，但是最大的区别就是data的数据，子组件可以随意改
		而父组件传递过来的数据，不能在子组件修改，如果非要对传递过来的数据进行修改
		那么可以根据传递过来的数据，计算自己的一份数据，然后可以修改，修改的时候修改的是自己计算的属性数据
		在计算的属性数据当中set，里面也不能直接操作传递过来的数据，得调用传过来的方法去修改

1、todoList交互（与用户的交互）
	添加todo
	鼠标移入移出
	单个修改和多个修改   单个修改状态及全选和全不选
	单个删除和多个删除






	刷新还是原来的效果，不会回到初始的情况（数据存储分析）
		一般监视和深度监视
		

	深度监视数据，保存
		数据需要变为json然后取存储，否则数据下次取到的就看不懂了内部会调用对象的toString，数据变了
	
	在data数据中，直接从localStorage中获取数据


	localStorage 和 sessionStorage 

	localStorage和sessionStorage 是h5新增的一种本地存储数据方式，本质是一个对象，存储量大小是														5M（chrome） 浏览器存储2.5 - 10

	localStorage保存数据是永久保存（持久化存储），关闭浏览器  重新打开数据还在
	sessionStorage 不是永久保存，会话存储。关闭浏览器数据清空

	
	这两个东西存储数据，默认数据都会转化为字符串,以后存储基本数据都是直接加引号变为字符串
	存储对象数据，数据就变了后期取出来就不是我们要的东西了
	因此在存储对象数据的时候，一定要自己强制转化为json串。这样它就不会再改变我的数据结构了，后期可以parse
	
	存储： localStorage.setItem(键，值)   增或者改
	获取： localStorage.getItem(键)       查   能获取到就获取到，获取不到返回null
	删除： localStorage.removeItem(键)    删除某个键值对
	改和增一样，第一次就是增后面就是改
	清空： localStorage.clear()


2、组件间通信
	
	1、props组件通信
		props组件通信是vue当中最基本的使用的最多的一个组件间通信方式
		适用场合：父子之间
		父组件给子组件传递非函数数据： 本质就是父组件给子组件传递数据
		父组件给子组件传递函数数据：本质其实是父组件想让子组件给自己传数据

	2、自定义事件组件通信

		事件分类：
			事件三要素：事件源 事件类型 回调函数
			原生dom事件
				事件类型：有限个
				回调函数：
					自己定义  浏览器调的
					默认参数：事件对象:  触发事件的时候，浏览器会操纵事件源调用回调函数，会把这一次触发事件相关的所有的信息封装成一个对象，通过实参
					传递给回调函数的第一个形参，这个对象我们称作是事件对象




			自定义事件
				事件类型：无数个
				回调函数：（其实说的是自己定义的函数）
					自己定义的  自己调的
					默认参数：自己传的 自己传了那就是自己传递的参数  没有传就是undefined

			注意：之前我们见到的一个词  $event就是默认参数
			以后如果这个事件是原生dom事件$event就是事件对象
			如果这个事件是自定义事件，$event是自己传递的


		自定义事件适用场合
			子向父

		如何用：	
			首先在父组件当中可以看到子组件标签（子组件标签其实就是子组件对象），
			在父组件当中我们可以给这个子组件标签添加一个事件（自定义）
			麻烦写法和简单写法都要会
			麻烦写法： 在mouted当中获取到子组件对象， this.$refs.header.$on('事件名'，回调函数)
			简单写法：<Header @addTodo="addTodo"></Header> 在子组件标签身上通过@绑定自定义事件及指定回调



			子组件内部可以在任何时候触发自己身上绑定的自定义事件，本质是自己在调用自己定义的事件回调
			this.$emit('事件名'，自己传递的参数)



			本质上我们其实还是在通过函数调用的形式进行传递数据
			父组件给子组件绑定自定义事件，回调是留在父组件当中
			子组件当中触发父组件给自己绑定的事件，同时传递自己想给父组件传递的数据
			所以它和props传递函数类似








	3、全局事件总线

		全局事件总线也是组件通信方式的一种，它的本质其实是一个对象

		全局事件总线对象要符合两个要求：
			1、所有的组件对象都可以找到（访问）到这个对象
			组件对象和vm的关系（vm的原型就是组件对象原型的原型）
			2、必须能调用$on和$emit

		在我们vue整个系统当中，最终vm是最适合的人选，后期我们是使用vm作为全局事件总线去使用的


		全局事件总线的使用
			1、安装总线
			2、在需要接收数据的组件当中，找到bus，给bus绑定自定义事件，但是事件回调留在当前组件
			3、在需要发送数据的组件当中，找到bus，触发bus绑定的自定义事件，调用事件的回调，通过函数传参把数据传递过去


