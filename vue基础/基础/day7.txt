1、props
2、自定义事件
3、全局事件总线
4、pubsub
5、插槽
	默认插槽
	具名插槽
	作用域插槽
6、vuex



跨域

	http请求分为两大类请求：普通请求和ajax请求
		普通请求不会跨域   （特点是刷新页面）
		ajax才会出现跨域   （局部更新，不刷新页面）


	什么跨域：
		违背浏览器上的同源策略，就称作跨域
		只有浏览器才会出现跨域

	什么是同源
		协议 ip 端口三者一致叫同源   （域名就是ip和端口）
		如果有一个不一样，就不同源（异源）

	怎么解决？
		1、jsonp
		2、cors头
		3、代理服务器

		1、当我们运行的项目的时候npm run serve，项目都会先进行打包，打包后再去运行

		2、我们的webpack在配置的时候装了一个插件，webpack-dev-server，它本质是一个服务器
		我们运行起来项目之后，在本地其实起了一个服务器，它会在浏览器发送请求的时候处理，返回我们
		打包的资源（dist）
		注意：没有webpackdevserver的时候dist是可以打包看到的，配置了以后
		dist打包后就会放在内存当中，我们看不到

		3、当打包完成后，我们输入localhost:8080，回车，其实是发了一个请求给本地服务器，本地服务器接收到请求后
		把dist当中的index.html返回给浏览器，浏览器会把内容进行渲染，我们就看到眼前的页面


		4、页面当中如果有发送ajax请求，那么此时，我们如果直接写的是目标服务器的地址，此时必然出现跨域
		因为我们目前站在本地的地址通过浏览器往另外一个真实服务器发请求，必然违背浏览器同源策略。所以浏览器往目标
		服务器去发送ajax请求，一般都会出现跨域。


		5、通过代理解决跨域其实就是一句话，把浏览器给目标服务器发送的请求转化为服务器往服务器发请求
		设置代理要明白下面步子：
		  1、如果我们写代码的时候，发送请求直接写的目标地址，协议  ip  端口都有，那么就是给目标服务器发请求（跨域）
          2、如果我们在写代码的时候，发送请求目标地址没有写协议、ip和端口，只写了路径，默认是给本地发的，不会跨域
          前面两步做完之后，我们是把浏览器往目标服务器发的请求转化浏览器往本地服务器发的请求

          3、通过配置本地开发服务器的代理，解决跨域
          	在安装webpack-dev-server的时候，这个服务器会自动安装一个中间件，http-proxy-middleware
          	这个中间件就有转发请求的功能

          	配置代理本质其实是在配置这个中间件，这个中间件不配，那么相当于没用，配置了，这个中间件就生效了（看门狗）

          	请求已经从给目标服务器转化到了给本地服务器，我们只需要告诉看门狗，哪些是需要转发的
          	那么我们后期只要是发给本地的请求，看门狗都去检查，如果检查到有需要转发的请求，就会转发请求


          Vue的配置代理写法

          devServer:{
          
          //看门狗
		    proxy: {
		      "/api": {
		        // /api代表转发标识，本质是路径的开头
		        // 这个标识有可能本身路径里就存在，也有可能是自己加的
		        // 只要往本地发的请求，都要去检查路径是不是以转发标识开头，如果是就转发


		        target: "http://localhost:3000",
		        // 目标，代表要转发的目标服务器地址，没有路径，只有协议 IP 端口
		        // 路径发往本地的请求当中已经有了

		        pathRewrite: {"^/api" : ""}
		        // 路径重写，要看最终目标服务器的路径当中有没有标识，如果本来就有这个标识
		        // 那么就不需要重写，如果本身，没有是自己加的，那么要重写掉这个标识
		      }
		    }
		  }


Vuex
	1、Vuex状态管理是什么：
		Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，是一个官方插件。
		它采用集中式存储管理应用的所有组件的状态（数据），并以相应的规则保证状态以一种可预测的方式发生变化。


		我们也可以认为它也是一种组件间通信的方式，并且适用于任意组件

	2、理解：对vue应用中多个组件的共享状态（数据）进行集中式的管理(读/写)
		

	3、为什么要有这个（问题）：
		1)多个视图依赖于同一状态

		2)来自不同视图的行为需要变更同一状态


		3)以前的解决办法
			a.将数据以及操作数据的行为都定义在父组件
			b.将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)

		4)vuex就是用来解决这个问题的


	4、什么时候用：
		Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。
		也就是说应用简单（组件比较少）就不需要使用（但是可以），如果应用复杂，使用就会带来很大的便捷
		
	

	5、Vuex核心：把所有的共享状态数据拿出来放在Vuex中进行集中式管理	
		1>vuex的配置
			1)安装vuex 3版本适配vue2 4版本适配vue3	
			2)创建一个文件夹，取名叫store 在文件夹内部创建index.js文件书写配置
				1、引入并声明使用插件
				2、向外暴露一个store对象
				3、在main.js当中实例化Vue的时候，注入store对象（每个组件当中都可以通过this.$store获取到当前store对象）
	
	6、vuex的核心概念




	6、count计数案例
		1、先按照组件开发不用vuex实现
		2、再用vuex实现
		3、简化操作
			下面这四个方法，都是vuex提供给我们简化数据和方法的操作
			mapState和mapGetters是简化数据的操作，可以把vuex当中数据，映射称为组件当中的数据
			mapState
			mapGetters

			mapMutations和mapActions是简化方法的操作，可以把vuex当中的方法，映射为组件当中的方法去调用，（用的很少）
			mapMutations
			mapActions


	7、vuex实现search_user