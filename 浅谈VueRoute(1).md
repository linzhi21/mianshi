# 浅谈VueRoute

1.VueRouter本质是一个构造函数，是一个npm包，是Vue的扩展插件，通过它可以实现单页面应用(SPA)。

2，通过VueRouter构造函数,可以获取路由器对象(router)，它给我们提供了两个全局组件.

### router-link

用户点击该标签,就会跳转到指定的路由地址

原理:

生成一个a标签,给该a标签绑定点击事件,禁用a标签的默认行为,调用编程式导航方法push或者replace实现路由跳转功能

##### router-view

路由组件的占位符，核心原理就是使用到了响应式原理

原理:

获取到当前页面的路由地址,在routes数组中找到匹配的路由,并获取他的component属性值,使用render方法,让router-view组件内部挂载流程中获取到的component组件进行展示

### 公共对象

#### $router

路由器对象,管理所有的路由,提供一些操作路由的API

##### push

跳转到指定路由地址,保留上一个的历史记录,说白了就是用户可以返回上一个路由

##### replace

跳转到指定路由地址,会覆盖上一个的历史记录,说白了就是用户无法返回上一个路由

#### $route

当前项目的路由对象,存储路由相关信息

##### query

路由传参的一种方式，路径拼接，?号隔开

##### params

路由传参的一种方式，路径拼接，/拼接

需要注意:必须在声明路由地址的时候,写好占位符

##### meta

在声明路由对象的时候,可以给对象添加meta属性,可以在用户跳转到该路由的时候,通过$route.meta访问

### 提供给VueRouter的东西

#### 配置对象

##### mode属性值有两个

hash值

开启hash模式的路由模式,特点就是路径中具有#/

history值

开启history模式的路由模式,特点就是路径中具有/

#### routes属性

routes是个数组，内部是一个个路由对象

对象的重要属性

1. path属性

   代表当前路由的路由地址

2. component属性

   如果当前路径中的地址与自己的path相同,那么就展示对应的路由组件

注意点:只有注册的路由组件,才能够访问使用

### 编程时导航和声明式导航的区别

##### 编程式导航:

使用js的某些API,实现的路由跳转

##### 声明式导航:

通过标签的形式,实现路由的跳转

### 导航守卫(又称为路由守卫)

一共分为三大类，这里简单说明常用的两个

##### 全局守卫

全局前置守卫(beforeEach)

在路由跳转之前执行

##### 路由独享守卫

在routes数组中的路由对象中配置(beforeEnter)

进入该路由之前会触发

# vue项目性能优化

## 一、代码层面的优化

### **v-if 和 v-show 区分使用场景**

v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。

### **computed 和 watch  区分使用场景**

当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；

当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch。

### v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

（1）v-for 遍历必须为 item 添加 key

（2）v-for 遍历避免同时使用 v-if

v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性

### 长列表性能优化

Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

### **事件的销毁**

Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。

### **图片资源懒加载**

对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验，我们在项目中使用 Vue 的 vue-lazyload 插件。

### 路由懒加载

Vue  是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。

### **第三方插件的按需引入**

我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 `babel-plugin-component` ，然后可以只引入需要的组件，以达到减小项目体积的目的。

### 优化无限列表性能

如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller  来优化这种无限列表的场景的。

## 二、Webpack 层面的优化

### Webpack 对图片进行压缩

在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片

### 减少 ES6 转为 ES5 的冗余代码

Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require('babel-runtime/helpers/createClass') 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。

### HMR 热模块替换

为什么要用？

默认情况下，一旦修改了代码，全部代码重新编译刷新，速度慢（全体刷新）

有什么作用？

只更新修改的模块，其他模块不变（局部更新）  

### 生产环境下不生成SourceMap(资源映射)

SourceMap(资源映射) 就是告诉我们我们写的代码在打包之后对应的是哪些
如果不生成SourceMap 那么打包的时候就会减少一些体积 所以会提升效率
需要在配置文件里配置 productionSourceMap: false 

### 文件名hash化

目的是为了利用浏览器的缓存机制来提高性能
浏览器会缓存文件，但是文件名如果不改变，浏览器不会缓存新的，因此我们要保证内容改变了，把文件名也改变，浏览器就会重新缓存新文件。如果内容没有变，文件名也不会变。浏览器就会拿缓存好的文件。这样对没更改的文件 就不会重新去加载了 直接从缓存里面读取就可以 提高了性能
默认脚手架已经配置好了，可以查看打包后的文件，都会有一个hash名字

### tree shaking( 摇树)

效果:打包时"摇掉"没有被使用的代码

	必须是ES6模块导出且进行代码压缩时 
	生产环境会摇,开发环境不会
	只有分别暴露的时候 才会摇
### 拆分打包与压缩,提取公共代码

对第三方js包,css进行拆分打包

抽取公共代码 

拆分多个文件，减少单个文件体积（避免单次请求时间过长）

### preload 和 prefetch 预加载

让资源提前加载

问题：兼容性较差 

使用Chrome团队提供的一个工具包: preload-webpack-plugin

对异步模块包使用: prefetch

对同步模块包使用: preload

## 三、基础的 Web 技术优化

### 开启 gzip 压缩

gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右

### **浏览器缓存**

为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存）

### **CDN 的使用**

浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。





好的可用性，更低的网络延迟和丢包率 。