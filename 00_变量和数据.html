<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /* 

  是什么  为什么   怎么玩
  1、内存的概念
      内存模型


  2、变量到底是什么?
    变量：可以变化的量  就叫变量
    常量：不能变化的量  叫常量   1
    
    变量的本质：变量其实是一个容器，用来装东西，
    在计算机的世界里，容器包含：cpu（寄存器） 内存 硬盘
    寄存器存储数据量很小，主要是cpu在做运算的时候临时使用，内存存储东西存储的比寄存器多，但是比硬盘少
    硬盘存储东西是最多的，他们三个人存储东西的速度是由高到低
    存储东西的持久化：内存存储东西不会持久化存储，硬盘会持久化存储

    变量在计算机当中，其实就是一小块内存，本质是一块内存空间

    
    程序进程线程
    程序：代码的集合 它是静态的 一般代表的是文件，存储在硬盘当中  
    进程：运行的程序，就叫进程，进程是动态的，每个进程包含自己的资源（cpu 内存 。。。）
          这些资源都是跟着程序的运行在发生变化的
    线程：线程依赖进程，每个进程当中至少要有一个线程（主线程），线程没有自己的资源，线程是要共享
    它所在进程当中的资源


  3、数据的分类******************
    从大的方向分为基本数据类型和引用数据类型
    基本数据：es5 Number  String  Boolean undefined null  es6+  symbol bigint
    引用数据：数组 Array  函数  Function  对象 Object （包装对象 Math  Date  RegExp）



 
  4、变量的类型*****
      js是弱类型语言：变量也有类型，只是我们不关注
      js当中变量的类型是由内部存储的值的类型决定
      
  5、 基本类型变量与引用类型变量的区别是什么?
    - 根据变量内存中保存的数据来区分
    - 基本类型变量: 内存中保存的基本类型的数据
    - 引用类型变量: 内存中保存的是引用数据所在内存的地址值
    把堆结构当中存储数据本身的内存地址值，赋值给栈结构当中变量的内存当中


  6、 数据类型的判定**************************
      typeof是一个操作符,他的结果是判定的数据，类型的小写字符串,但是有缺陷
      作用：用来判断数据类型，（用来判断一个值得类型）,typeof后面放的是有值得东西
      js当中有值得东西： 值本身  变量（变量放在操作符后面，就是值） 表达式

      typeof a
      typeof 100
      typeof a + b

      typeof判定我们常用的8种类型  5种基本数据+3种引用数据
      var a = 100  //'number'
      a = 'zhaoliying'  //'string'
      a = true //'boolean'
      a = undefined // 'undefined'
      a = null // 'object'
        1、设计缺陷
        2、null经常在哪用？ 1》初始化一个对象 2》删除一个对象

      typeof本身就不是用来判定引用数据类型的，因此判定引用数据不准，所以后期才有instanceof
      a = [1,2,3] // 'object'
      a = function(){} // 'function'
      a = {} // 'object'


      typeof在判定 null  数组和对象都会是object字符串
      后期instanceof可以帮我们判定数组和对象 

      null是没办法使用typeof 和 instanceof去判定死的
      ===可以帮我们判定 undefined和null


  7、 给变量赋值到底做了什么?
      基本类型的变量，把基本数据值本身存储到变量所代表的栈结构内存当中
      引用类型的变量，把引用数据值所在堆结构当中内存的地址值，存储到变量所代表的栈结构内存当中
      // a = 100
      // a = {}

      // 赋值除了给变量就是给属性
      把基本数据值本身存储到堆结构内存当中对象的属性
      把引用数据类型的数据所在堆结构当中的地址值，赋值给堆结构内存当中对象的属性
      // a.b = 100
      // a.b = {}

  8、 如何理解下面2句重要的话(编码演示说明)?*********************
    - 2个引用变量指向同一个对象, 如果通过一个变量修改对象内部的数据 => 另一个变量也能看到原对象(新数据)
      var a = {m:1}
      var b = a
      a.m = 2
      log(b)   //{m:2}



    - 2个引用变量指向同一个对象, 让其中一个变量指向一个新的对象 => 另一个引用变量看到的是老的对象
      var a = {m:1}
      var b = a
      a = {m:1}
      log(b)








  9、 函数传参, 到底是值传递还是引用（地址）传递?  ************************
  
  //值传递
  var a = 10
  function fn(a){
    a = 20
    log(a)
  }
  fn(a) //函数传参本质是？把实参的值，赋值给形参变量  形参本质是一个变量
  log(a)

  var a = 10
  var b = a
  a = 20
  b?

------------------------------
//  地址值传递
  var a = {m:1}
  function fn1(a){
    a.m = 100
    log(a) 
  }
  fn1(a)
  log(a)


  var a = {m:1}
  var b = a
  a.m = 2
  log(b)   //{m:2}

------------------------------
// 地址值传递
  var a = {m:1}
  function fn1(a){
    a = {m:2}
    log(a) 
  }
  fn1(a)
  log(a)


  var a = {m:1}
  var b = a
  a.m = 2
  log(b)   //{m:2}


  10、 有哪些改变变量值的方式?
    - 只能通过赋值改变
    - c.m = 2: 改的是c变量指向的对象内部的属性数据, c本身没有变化的(对象内存的位置没变)

  11、 表达式a.b的解析流程
  1、先根据作用域链去查找a
      a的值，分为基本值和引用值
      如果没找a，直接报错，引用错误
  2、再去解析.b
      1）a是一个基本值
        假设a是Number  String Boolean，他们是有包装对象的，所以不会报错
        根据原型链到包装对象身上去找b，如果找到就拿到b的值，找不到返回undefined
        假设a是undefined或者null，他们直接报错（类型错误）
        错误：语法错误 引用错误 类型错误 范围错误
      2）a是一个引用值
        根据原型链到对象身上去找b，如果找到就拿到b的值，找不到返回undefined
  */
      
    </script>
  </body>
</html>
